<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rugby Coaching Tool</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #field {
      position: relative;
      width: 100%;
      max-width: 1200px;
      aspect-ratio: 100 / 70;
      background-image: url('H.png');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      overflow: hidden;
    }

    .player, .ball {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      text-align: center;
      line-height: 40px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      transition: left 0.5s ease, top 0.5s ease;
    }

    .player.attacking {
      background-color: red;
      color: white;
    }

    .player.defending {
      background-color: blue;
      color: white;
    }

    .tackle {
      background-color: purple !important;
    }

    .ball {
      background-color: transparent;
      font-size: 24px;
      width: 30px;
      height: 30px;
      line-height: 30px;
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    button {
      padding: 5px 10px;
      font-size: 14px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button onclick="addPlayer('attacking')">Add Attacker</button>
    <button onclick="addPlayer('defending')">Add Defender</button>
    <button onclick="addBall()">Add Ball</button>
    <button onclick="saveStep()">Save Step</button>
    <button onclick="playSteps()">Play</button>
    <button onclick="pauseSteps()">Pause</button>
    <button onclick="reset()">Reset</button>
  </div>
  <div id="field"></div>

  <script>
    const field = document.getElementById('field');
    const maxPlayers = 15;
    let attackingCount = 0;
    let defendingCount = 0;
    let dragging = null;
    let offsetX = 0;
    let offsetY = 0;
    let ballAdded = false;
    let steps = [];
    let currentStep = 0;
    let interval;

    function createElement(type, className, text) {
      const el = document.createElement('div');
      el.classList.add(type, className);
      el.innerText = text;
      field.appendChild(el);

      el.style.left = `${field.clientWidth / 2 - 20}px`;
      el.style.top = `${field.clientHeight / 2 - 20}px`;

      el.addEventListener('mousedown', e => {
        dragging = el;
        offsetX = e.offsetX;
        offsetY = e.offsetY;
      });

      return el;
    }

    function addPlayer(team) {
      if (team === 'attacking' && attackingCount >= maxPlayers) return;
      if (team === 'defending' && defendingCount >= maxPlayers) return;

      const number = team === 'attacking' ? ++attackingCount : ++defendingCount;
      const player = createElement('player', team, number);
      player.dataset.team = team;
    }

    function addBall() {
      if (ballAdded) return;
      const ball = createElement('ball', '', '🏉');
      ball.classList.add('ball');
      ballAdded = true;
    }

    document.addEventListener('mouseup', () => dragging = null);

    document.addEventListener('mousemove', e => {
      if (dragging) {
        const rect = field.getBoundingClientRect();
        let x = e.clientX - rect.left - offsetX;
        let y = e.clientY - rect.top - offsetY;

        // Keep elements within bounds
        x = Math.max(0, Math.min(x, field.clientWidth - dragging.offsetWidth));
        y = Math.max(0, Math.min(y, field.clientHeight - dragging.offsetHeight));

        dragging.style.left = `${x}px`;
        dragging.style.top = `${y}px`;

        if (dragging.classList.contains('player')) {
          detectTackles();
        }
      }
    });

    function saveStep() {
      const state = Array.from(field.children).map(el => ({
        type: el.className,
        text: el.innerText,
        left: el.style.left,
        top: el.style.top,
        team: el.dataset?.team
      }));
      steps.push(state);
    }

    function reset() {
      field.innerHTML = '';
      attackingCount = 0;
      defendingCount = 0;
      ballAdded = false;
      steps = [];
      currentStep = 0;
      pauseSteps();
    }

    function playSteps() {
      if (!steps.length) return;
      pauseSteps();
      interval = setInterval(() => {
        if (currentStep >= steps.length) {
          pauseSteps();
          return;
        }
        loadStep(steps[currentStep]);
        currentStep++;
      }, 800);
    }

    function pauseSteps() {
      clearInterval(interval);
    }

    function loadStep(step) {
      field.innerHTML = '';
      step.forEach(item => {
        const el = createElement(
          item.type.includes('ball') ? 'ball' : 'player',
          item.team || '',
          item.text
        );
        el.style.left = item.left;
        el.style.top = item.top;
        if (item.team) el.dataset.team = item.team;
      });
      detectTackles();
    }

    function detectTackles() {
      const attackers = Array.from(field.querySelectorAll('.player.attacking'));
      const defenders = Array.from(field.querySelectorAll('.player.defending'));
      attackers.forEach(att => {
        const attRect = att.getBoundingClientRect();
        defenders.forEach(def => {
          const defRect = def.getBoundingClientRect();
          const dx = attRect.left - defRect.left;
          const dy = attRect.top - defRect.top;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < 50) {
            att.classList.add('tackle');
            def.classList.add('tackle');
          } else {
            att.classList.remove('tackle');
            def.classList.remove('tackle');
          }
        });
      });
    }
  </script>
</body>
</html>
